// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Msg_Login.proto

#ifndef PROTOBUF_Msg_5fLogin_2eproto__INCLUDED
#define PROTOBUF_Msg_5fLogin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Msg_5fLogin_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsCheckVersionReqImpl();
void InitDefaultsCheckVersionReq();
void InitDefaultsCheckVersionAckImpl();
void InitDefaultsCheckVersionAck();
void InitDefaultsClientServerListReqImpl();
void InitDefaultsClientServerListReq();
void InitDefaultsClientServerNodeImpl();
void InitDefaultsClientServerNode();
void InitDefaultsClientServerListAckImpl();
void InitDefaultsClientServerListAck();
void InitDefaultsSelectServerReqImpl();
void InitDefaultsSelectServerReq();
void InitDefaultsSelectServerAckImpl();
void InitDefaultsSelectServerAck();
void InitDefaultsLogicRegToLoginReqImpl();
void InitDefaultsLogicRegToLoginReq();
void InitDefaultsLogicRegToLoginAckImpl();
void InitDefaultsLogicRegToLoginAck();
inline void InitDefaults() {
  InitDefaultsCheckVersionReq();
  InitDefaultsCheckVersionAck();
  InitDefaultsClientServerListReq();
  InitDefaultsClientServerNode();
  InitDefaultsClientServerListAck();
  InitDefaultsSelectServerReq();
  InitDefaultsSelectServerAck();
  InitDefaultsLogicRegToLoginReq();
  InitDefaultsLogicRegToLoginAck();
}
}  // namespace protobuf_Msg_5fLogin_2eproto
class CheckVersionAck;
class CheckVersionAckDefaultTypeInternal;
extern CheckVersionAckDefaultTypeInternal _CheckVersionAck_default_instance_;
class CheckVersionReq;
class CheckVersionReqDefaultTypeInternal;
extern CheckVersionReqDefaultTypeInternal _CheckVersionReq_default_instance_;
class ClientServerListAck;
class ClientServerListAckDefaultTypeInternal;
extern ClientServerListAckDefaultTypeInternal _ClientServerListAck_default_instance_;
class ClientServerListReq;
class ClientServerListReqDefaultTypeInternal;
extern ClientServerListReqDefaultTypeInternal _ClientServerListReq_default_instance_;
class ClientServerNode;
class ClientServerNodeDefaultTypeInternal;
extern ClientServerNodeDefaultTypeInternal _ClientServerNode_default_instance_;
class LogicRegToLoginAck;
class LogicRegToLoginAckDefaultTypeInternal;
extern LogicRegToLoginAckDefaultTypeInternal _LogicRegToLoginAck_default_instance_;
class LogicRegToLoginReq;
class LogicRegToLoginReqDefaultTypeInternal;
extern LogicRegToLoginReqDefaultTypeInternal _LogicRegToLoginReq_default_instance_;
class SelectServerAck;
class SelectServerAckDefaultTypeInternal;
extern SelectServerAckDefaultTypeInternal _SelectServerAck_default_instance_;
class SelectServerReq;
class SelectServerReqDefaultTypeInternal;
extern SelectServerReqDefaultTypeInternal _SelectServerReq_default_instance_;

// ===================================================================

class CheckVersionReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CheckVersionReq) */ {
 public:
  CheckVersionReq();
  virtual ~CheckVersionReq();

  CheckVersionReq(const CheckVersionReq& from);

  inline CheckVersionReq& operator=(const CheckVersionReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckVersionReq(CheckVersionReq&& from) noexcept
    : CheckVersionReq() {
    *this = ::std::move(from);
  }

  inline CheckVersionReq& operator=(CheckVersionReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckVersionReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckVersionReq* internal_default_instance() {
    return reinterpret_cast<const CheckVersionReq*>(
               &_CheckVersionReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(CheckVersionReq* other);
  friend void swap(CheckVersionReq& a, CheckVersionReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckVersionReq* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckVersionReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckVersionReq& from);
  void MergeFrom(const CheckVersionReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckVersionReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ClientVerion = 1;
  void clear_clientverion();
  static const int kClientVerionFieldNumber = 1;
  const ::std::string& clientverion() const;
  void set_clientverion(const ::std::string& value);
  #if LANG_CXX11
  void set_clientverion(::std::string&& value);
  #endif
  void set_clientverion(const char* value);
  void set_clientverion(const char* value, size_t size);
  ::std::string* mutable_clientverion();
  ::std::string* release_clientverion();
  void set_allocated_clientverion(::std::string* clientverion);

  // int32 Channel = 2;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::google::protobuf::int32 channel() const;
  void set_channel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CheckVersionReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientverion_;
  ::google::protobuf::int32 channel_;
  mutable int _cached_size_;
  friend struct ::protobuf_Msg_5fLogin_2eproto::TableStruct;
  friend void ::protobuf_Msg_5fLogin_2eproto::InitDefaultsCheckVersionReqImpl();
};
// -------------------------------------------------------------------

class CheckVersionAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CheckVersionAck) */ {
 public:
  CheckVersionAck();
  virtual ~CheckVersionAck();

  CheckVersionAck(const CheckVersionAck& from);

  inline CheckVersionAck& operator=(const CheckVersionAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckVersionAck(CheckVersionAck&& from) noexcept
    : CheckVersionAck() {
    *this = ::std::move(from);
  }

  inline CheckVersionAck& operator=(CheckVersionAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckVersionAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckVersionAck* internal_default_instance() {
    return reinterpret_cast<const CheckVersionAck*>(
               &_CheckVersionAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CheckVersionAck* other);
  friend void swap(CheckVersionAck& a, CheckVersionAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckVersionAck* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckVersionAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckVersionAck& from);
  void MergeFrom(const CheckVersionAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckVersionAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ClientVerion = 2;
  void clear_clientverion();
  static const int kClientVerionFieldNumber = 2;
  const ::std::string& clientverion() const;
  void set_clientverion(const ::std::string& value);
  #if LANG_CXX11
  void set_clientverion(::std::string&& value);
  #endif
  void set_clientverion(const char* value);
  void set_clientverion(const char* value, size_t size);
  ::std::string* mutable_clientverion();
  ::std::string* release_clientverion();
  void set_allocated_clientverion(::std::string* clientverion);

  // uint32 RetCode = 1;
  void clear_retcode();
  static const int kRetCodeFieldNumber = 1;
  ::google::protobuf::uint32 retcode() const;
  void set_retcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CheckVersionAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientverion_;
  ::google::protobuf::uint32 retcode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Msg_5fLogin_2eproto::TableStruct;
  friend void ::protobuf_Msg_5fLogin_2eproto::InitDefaultsCheckVersionAckImpl();
};
// -------------------------------------------------------------------

class ClientServerListReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ClientServerListReq) */ {
 public:
  ClientServerListReq();
  virtual ~ClientServerListReq();

  ClientServerListReq(const ClientServerListReq& from);

  inline ClientServerListReq& operator=(const ClientServerListReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientServerListReq(ClientServerListReq&& from) noexcept
    : ClientServerListReq() {
    *this = ::std::move(from);
  }

  inline ClientServerListReq& operator=(ClientServerListReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientServerListReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientServerListReq* internal_default_instance() {
    return reinterpret_cast<const ClientServerListReq*>(
               &_ClientServerListReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ClientServerListReq* other);
  friend void swap(ClientServerListReq& a, ClientServerListReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientServerListReq* New() const PROTOBUF_FINAL { return New(NULL); }

  ClientServerListReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClientServerListReq& from);
  void MergeFrom(const ClientServerListReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClientServerListReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ClientVersion = 3;
  void clear_clientversion();
  static const int kClientVersionFieldNumber = 3;
  const ::std::string& clientversion() const;
  void set_clientversion(const ::std::string& value);
  #if LANG_CXX11
  void set_clientversion(::std::string&& value);
  #endif
  void set_clientversion(const char* value);
  void set_clientversion(const char* value, size_t size);
  ::std::string* mutable_clientversion();
  ::std::string* release_clientversion();
  void set_allocated_clientversion(::std::string* clientversion);

  // uint64 AccountID = 1;
  void clear_accountid();
  static const int kAccountIDFieldNumber = 1;
  ::google::protobuf::uint64 accountid() const;
  void set_accountid(::google::protobuf::uint64 value);

  // int32 Channel = 2;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::google::protobuf::int32 channel() const;
  void set_channel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClientServerListReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientversion_;
  ::google::protobuf::uint64 accountid_;
  ::google::protobuf::int32 channel_;
  mutable int _cached_size_;
  friend struct ::protobuf_Msg_5fLogin_2eproto::TableStruct;
  friend void ::protobuf_Msg_5fLogin_2eproto::InitDefaultsClientServerListReqImpl();
};
// -------------------------------------------------------------------

class ClientServerNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ClientServerNode) */ {
 public:
  ClientServerNode();
  virtual ~ClientServerNode();

  ClientServerNode(const ClientServerNode& from);

  inline ClientServerNode& operator=(const ClientServerNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientServerNode(ClientServerNode&& from) noexcept
    : ClientServerNode() {
    *this = ::std::move(from);
  }

  inline ClientServerNode& operator=(ClientServerNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientServerNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientServerNode* internal_default_instance() {
    return reinterpret_cast<const ClientServerNode*>(
               &_ClientServerNode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ClientServerNode* other);
  friend void swap(ClientServerNode& a, ClientServerNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientServerNode* New() const PROTOBUF_FINAL { return New(NULL); }

  ClientServerNode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClientServerNode& from);
  void MergeFrom(const ClientServerNode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClientServerNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string SvrName = 2;
  void clear_svrname();
  static const int kSvrNameFieldNumber = 2;
  const ::std::string& svrname() const;
  void set_svrname(const ::std::string& value);
  #if LANG_CXX11
  void set_svrname(::std::string&& value);
  #endif
  void set_svrname(const char* value);
  void set_svrname(const char* value, size_t size);
  ::std::string* mutable_svrname();
  ::std::string* release_svrname();
  void set_allocated_svrname(::std::string* svrname);

  // int32 SvrID = 1;
  void clear_svrid();
  static const int kSvrIDFieldNumber = 1;
  ::google::protobuf::int32 svrid() const;
  void set_svrid(::google::protobuf::int32 value);

  // int32 SvrState = 3;
  void clear_svrstate();
  static const int kSvrStateFieldNumber = 3;
  ::google::protobuf::int32 svrstate() const;
  void set_svrstate(::google::protobuf::int32 value);

  // int32 SvrFlag = 4;
  void clear_svrflag();
  static const int kSvrFlagFieldNumber = 4;
  ::google::protobuf::int32 svrflag() const;
  void set_svrflag(::google::protobuf::int32 value);

  // int32 SvrOpenTime = 5;
  void clear_svropentime();
  static const int kSvrOpenTimeFieldNumber = 5;
  ::google::protobuf::int32 svropentime() const;
  void set_svropentime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClientServerNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr svrname_;
  ::google::protobuf::int32 svrid_;
  ::google::protobuf::int32 svrstate_;
  ::google::protobuf::int32 svrflag_;
  ::google::protobuf::int32 svropentime_;
  mutable int _cached_size_;
  friend struct ::protobuf_Msg_5fLogin_2eproto::TableStruct;
  friend void ::protobuf_Msg_5fLogin_2eproto::InitDefaultsClientServerNodeImpl();
};
// -------------------------------------------------------------------

class ClientServerListAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ClientServerListAck) */ {
 public:
  ClientServerListAck();
  virtual ~ClientServerListAck();

  ClientServerListAck(const ClientServerListAck& from);

  inline ClientServerListAck& operator=(const ClientServerListAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientServerListAck(ClientServerListAck&& from) noexcept
    : ClientServerListAck() {
    *this = ::std::move(from);
  }

  inline ClientServerListAck& operator=(ClientServerListAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientServerListAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientServerListAck* internal_default_instance() {
    return reinterpret_cast<const ClientServerListAck*>(
               &_ClientServerListAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ClientServerListAck* other);
  friend void swap(ClientServerListAck& a, ClientServerListAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientServerListAck* New() const PROTOBUF_FINAL { return New(NULL); }

  ClientServerListAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClientServerListAck& from);
  void MergeFrom(const ClientServerListAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClientServerListAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ClientServerNode SvrNode = 2;
  int svrnode_size() const;
  void clear_svrnode();
  static const int kSvrNodeFieldNumber = 2;
  const ::ClientServerNode& svrnode(int index) const;
  ::ClientServerNode* mutable_svrnode(int index);
  ::ClientServerNode* add_svrnode();
  ::google::protobuf::RepeatedPtrField< ::ClientServerNode >*
      mutable_svrnode();
  const ::google::protobuf::RepeatedPtrField< ::ClientServerNode >&
      svrnode() const;

  // uint32 RetCode = 1;
  void clear_retcode();
  static const int kRetCodeFieldNumber = 1;
  ::google::protobuf::uint32 retcode() const;
  void set_retcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ClientServerListAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ClientServerNode > svrnode_;
  ::google::protobuf::uint32 retcode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Msg_5fLogin_2eproto::TableStruct;
  friend void ::protobuf_Msg_5fLogin_2eproto::InitDefaultsClientServerListAckImpl();
};
// -------------------------------------------------------------------

class SelectServerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SelectServerReq) */ {
 public:
  SelectServerReq();
  virtual ~SelectServerReq();

  SelectServerReq(const SelectServerReq& from);

  inline SelectServerReq& operator=(const SelectServerReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectServerReq(SelectServerReq&& from) noexcept
    : SelectServerReq() {
    *this = ::std::move(from);
  }

  inline SelectServerReq& operator=(SelectServerReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectServerReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SelectServerReq* internal_default_instance() {
    return reinterpret_cast<const SelectServerReq*>(
               &_SelectServerReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SelectServerReq* other);
  friend void swap(SelectServerReq& a, SelectServerReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectServerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectServerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectServerReq& from);
  void MergeFrom(const SelectServerReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectServerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 ServerID = 1;
  void clear_serverid();
  static const int kServerIDFieldNumber = 1;
  ::google::protobuf::int32 serverid() const;
  void set_serverid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SelectServerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 serverid_;
  mutable int _cached_size_;
  friend struct ::protobuf_Msg_5fLogin_2eproto::TableStruct;
  friend void ::protobuf_Msg_5fLogin_2eproto::InitDefaultsSelectServerReqImpl();
};
// -------------------------------------------------------------------

class SelectServerAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SelectServerAck) */ {
 public:
  SelectServerAck();
  virtual ~SelectServerAck();

  SelectServerAck(const SelectServerAck& from);

  inline SelectServerAck& operator=(const SelectServerAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectServerAck(SelectServerAck&& from) noexcept
    : SelectServerAck() {
    *this = ::std::move(from);
  }

  inline SelectServerAck& operator=(SelectServerAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectServerAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SelectServerAck* internal_default_instance() {
    return reinterpret_cast<const SelectServerAck*>(
               &_SelectServerAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(SelectServerAck* other);
  friend void swap(SelectServerAck& a, SelectServerAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectServerAck* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectServerAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectServerAck& from);
  void MergeFrom(const SelectServerAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectServerAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ServerAddr = 3;
  void clear_serveraddr();
  static const int kServerAddrFieldNumber = 3;
  const ::std::string& serveraddr() const;
  void set_serveraddr(const ::std::string& value);
  #if LANG_CXX11
  void set_serveraddr(::std::string&& value);
  #endif
  void set_serveraddr(const char* value);
  void set_serveraddr(const char* value, size_t size);
  ::std::string* mutable_serveraddr();
  ::std::string* release_serveraddr();
  void set_allocated_serveraddr(::std::string* serveraddr);

  // uint32 RetCode = 1;
  void clear_retcode();
  static const int kRetCodeFieldNumber = 1;
  ::google::protobuf::uint32 retcode() const;
  void set_retcode(::google::protobuf::uint32 value);

  // int32 ServerID = 2;
  void clear_serverid();
  static const int kServerIDFieldNumber = 2;
  ::google::protobuf::int32 serverid() const;
  void set_serverid(::google::protobuf::int32 value);

  // int32 ServerPort = 4;
  void clear_serverport();
  static const int kServerPortFieldNumber = 4;
  ::google::protobuf::int32 serverport() const;
  void set_serverport(::google::protobuf::int32 value);

  // int32 LoginCode = 5;
  void clear_logincode();
  static const int kLoginCodeFieldNumber = 5;
  ::google::protobuf::int32 logincode() const;
  void set_logincode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SelectServerAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr serveraddr_;
  ::google::protobuf::uint32 retcode_;
  ::google::protobuf::int32 serverid_;
  ::google::protobuf::int32 serverport_;
  ::google::protobuf::int32 logincode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Msg_5fLogin_2eproto::TableStruct;
  friend void ::protobuf_Msg_5fLogin_2eproto::InitDefaultsSelectServerAckImpl();
};
// -------------------------------------------------------------------

class LogicRegToLoginReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LogicRegToLoginReq) */ {
 public:
  LogicRegToLoginReq();
  virtual ~LogicRegToLoginReq();

  LogicRegToLoginReq(const LogicRegToLoginReq& from);

  inline LogicRegToLoginReq& operator=(const LogicRegToLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogicRegToLoginReq(LogicRegToLoginReq&& from) noexcept
    : LogicRegToLoginReq() {
    *this = ::std::move(from);
  }

  inline LogicRegToLoginReq& operator=(LogicRegToLoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicRegToLoginReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicRegToLoginReq* internal_default_instance() {
    return reinterpret_cast<const LogicRegToLoginReq*>(
               &_LogicRegToLoginReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(LogicRegToLoginReq* other);
  friend void swap(LogicRegToLoginReq& a, LogicRegToLoginReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogicRegToLoginReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LogicRegToLoginReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogicRegToLoginReq& from);
  void MergeFrom(const LogicRegToLoginReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogicRegToLoginReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ServerName = 2;
  void clear_servername();
  static const int kServerNameFieldNumber = 2;
  const ::std::string& servername() const;
  void set_servername(const ::std::string& value);
  #if LANG_CXX11
  void set_servername(::std::string&& value);
  #endif
  void set_servername(const char* value);
  void set_servername(const char* value, size_t size);
  ::std::string* mutable_servername();
  ::std::string* release_servername();
  void set_allocated_servername(::std::string* servername);

  // string ServerIp = 3;
  void clear_serverip();
  static const int kServerIpFieldNumber = 3;
  const ::std::string& serverip() const;
  void set_serverip(const ::std::string& value);
  #if LANG_CXX11
  void set_serverip(::std::string&& value);
  #endif
  void set_serverip(const char* value);
  void set_serverip(const char* value, size_t size);
  ::std::string* mutable_serverip();
  ::std::string* release_serverip();
  void set_allocated_serverip(::std::string* serverip);

  // int32 ServerID = 1;
  void clear_serverid();
  static const int kServerIDFieldNumber = 1;
  ::google::protobuf::int32 serverid() const;
  void set_serverid(::google::protobuf::int32 value);

  // int32 ServerPort = 4;
  void clear_serverport();
  static const int kServerPortFieldNumber = 4;
  ::google::protobuf::int32 serverport() const;
  void set_serverport(::google::protobuf::int32 value);

  // int32 HttpPort = 5;
  void clear_httpport();
  static const int kHttpPortFieldNumber = 5;
  ::google::protobuf::int32 httpport() const;
  void set_httpport(::google::protobuf::int32 value);

  // int32 WatchPort = 6;
  void clear_watchport();
  static const int kWatchPortFieldNumber = 6;
  ::google::protobuf::int32 watchport() const;
  void set_watchport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LogicRegToLoginReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr servername_;
  ::google::protobuf::internal::ArenaStringPtr serverip_;
  ::google::protobuf::int32 serverid_;
  ::google::protobuf::int32 serverport_;
  ::google::protobuf::int32 httpport_;
  ::google::protobuf::int32 watchport_;
  mutable int _cached_size_;
  friend struct ::protobuf_Msg_5fLogin_2eproto::TableStruct;
  friend void ::protobuf_Msg_5fLogin_2eproto::InitDefaultsLogicRegToLoginReqImpl();
};
// -------------------------------------------------------------------

class LogicRegToLoginAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LogicRegToLoginAck) */ {
 public:
  LogicRegToLoginAck();
  virtual ~LogicRegToLoginAck();

  LogicRegToLoginAck(const LogicRegToLoginAck& from);

  inline LogicRegToLoginAck& operator=(const LogicRegToLoginAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogicRegToLoginAck(LogicRegToLoginAck&& from) noexcept
    : LogicRegToLoginAck() {
    *this = ::std::move(from);
  }

  inline LogicRegToLoginAck& operator=(LogicRegToLoginAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicRegToLoginAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicRegToLoginAck* internal_default_instance() {
    return reinterpret_cast<const LogicRegToLoginAck*>(
               &_LogicRegToLoginAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(LogicRegToLoginAck* other);
  friend void swap(LogicRegToLoginAck& a, LogicRegToLoginAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogicRegToLoginAck* New() const PROTOBUF_FINAL { return New(NULL); }

  LogicRegToLoginAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogicRegToLoginAck& from);
  void MergeFrom(const LogicRegToLoginAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogicRegToLoginAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string NewSvrName = 2;
  void clear_newsvrname();
  static const int kNewSvrNameFieldNumber = 2;
  const ::std::string& newsvrname() const;
  void set_newsvrname(const ::std::string& value);
  #if LANG_CXX11
  void set_newsvrname(::std::string&& value);
  #endif
  void set_newsvrname(const char* value);
  void set_newsvrname(const char* value, size_t size);
  ::std::string* mutable_newsvrname();
  ::std::string* release_newsvrname();
  void set_allocated_newsvrname(::std::string* newsvrname);

  // uint32 RetCode = 1;
  void clear_retcode();
  static const int kRetCodeFieldNumber = 1;
  ::google::protobuf::uint32 retcode() const;
  void set_retcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:LogicRegToLoginAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr newsvrname_;
  ::google::protobuf::uint32 retcode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Msg_5fLogin_2eproto::TableStruct;
  friend void ::protobuf_Msg_5fLogin_2eproto::InitDefaultsLogicRegToLoginAckImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CheckVersionReq

// string ClientVerion = 1;
inline void CheckVersionReq::clear_clientverion() {
  clientverion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CheckVersionReq::clientverion() const {
  // @@protoc_insertion_point(field_get:CheckVersionReq.ClientVerion)
  return clientverion_.GetNoArena();
}
inline void CheckVersionReq::set_clientverion(const ::std::string& value) {
  
  clientverion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CheckVersionReq.ClientVerion)
}
#if LANG_CXX11
inline void CheckVersionReq::set_clientverion(::std::string&& value) {
  
  clientverion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CheckVersionReq.ClientVerion)
}
#endif
inline void CheckVersionReq::set_clientverion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientverion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CheckVersionReq.ClientVerion)
}
inline void CheckVersionReq::set_clientverion(const char* value, size_t size) {
  
  clientverion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CheckVersionReq.ClientVerion)
}
inline ::std::string* CheckVersionReq::mutable_clientverion() {
  
  // @@protoc_insertion_point(field_mutable:CheckVersionReq.ClientVerion)
  return clientverion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CheckVersionReq::release_clientverion() {
  // @@protoc_insertion_point(field_release:CheckVersionReq.ClientVerion)
  
  return clientverion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckVersionReq::set_allocated_clientverion(::std::string* clientverion) {
  if (clientverion != NULL) {
    
  } else {
    
  }
  clientverion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientverion);
  // @@protoc_insertion_point(field_set_allocated:CheckVersionReq.ClientVerion)
}

// int32 Channel = 2;
inline void CheckVersionReq::clear_channel() {
  channel_ = 0;
}
inline ::google::protobuf::int32 CheckVersionReq::channel() const {
  // @@protoc_insertion_point(field_get:CheckVersionReq.Channel)
  return channel_;
}
inline void CheckVersionReq::set_channel(::google::protobuf::int32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:CheckVersionReq.Channel)
}

// -------------------------------------------------------------------

// CheckVersionAck

// uint32 RetCode = 1;
inline void CheckVersionAck::clear_retcode() {
  retcode_ = 0u;
}
inline ::google::protobuf::uint32 CheckVersionAck::retcode() const {
  // @@protoc_insertion_point(field_get:CheckVersionAck.RetCode)
  return retcode_;
}
inline void CheckVersionAck::set_retcode(::google::protobuf::uint32 value) {
  
  retcode_ = value;
  // @@protoc_insertion_point(field_set:CheckVersionAck.RetCode)
}

// string ClientVerion = 2;
inline void CheckVersionAck::clear_clientverion() {
  clientverion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CheckVersionAck::clientverion() const {
  // @@protoc_insertion_point(field_get:CheckVersionAck.ClientVerion)
  return clientverion_.GetNoArena();
}
inline void CheckVersionAck::set_clientverion(const ::std::string& value) {
  
  clientverion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CheckVersionAck.ClientVerion)
}
#if LANG_CXX11
inline void CheckVersionAck::set_clientverion(::std::string&& value) {
  
  clientverion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CheckVersionAck.ClientVerion)
}
#endif
inline void CheckVersionAck::set_clientverion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientverion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CheckVersionAck.ClientVerion)
}
inline void CheckVersionAck::set_clientverion(const char* value, size_t size) {
  
  clientverion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CheckVersionAck.ClientVerion)
}
inline ::std::string* CheckVersionAck::mutable_clientverion() {
  
  // @@protoc_insertion_point(field_mutable:CheckVersionAck.ClientVerion)
  return clientverion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CheckVersionAck::release_clientverion() {
  // @@protoc_insertion_point(field_release:CheckVersionAck.ClientVerion)
  
  return clientverion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckVersionAck::set_allocated_clientverion(::std::string* clientverion) {
  if (clientverion != NULL) {
    
  } else {
    
  }
  clientverion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientverion);
  // @@protoc_insertion_point(field_set_allocated:CheckVersionAck.ClientVerion)
}

// -------------------------------------------------------------------

// ClientServerListReq

// uint64 AccountID = 1;
inline void ClientServerListReq::clear_accountid() {
  accountid_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ClientServerListReq::accountid() const {
  // @@protoc_insertion_point(field_get:ClientServerListReq.AccountID)
  return accountid_;
}
inline void ClientServerListReq::set_accountid(::google::protobuf::uint64 value) {
  
  accountid_ = value;
  // @@protoc_insertion_point(field_set:ClientServerListReq.AccountID)
}

// int32 Channel = 2;
inline void ClientServerListReq::clear_channel() {
  channel_ = 0;
}
inline ::google::protobuf::int32 ClientServerListReq::channel() const {
  // @@protoc_insertion_point(field_get:ClientServerListReq.Channel)
  return channel_;
}
inline void ClientServerListReq::set_channel(::google::protobuf::int32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:ClientServerListReq.Channel)
}

// string ClientVersion = 3;
inline void ClientServerListReq::clear_clientversion() {
  clientversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientServerListReq::clientversion() const {
  // @@protoc_insertion_point(field_get:ClientServerListReq.ClientVersion)
  return clientversion_.GetNoArena();
}
inline void ClientServerListReq::set_clientversion(const ::std::string& value) {
  
  clientversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ClientServerListReq.ClientVersion)
}
#if LANG_CXX11
inline void ClientServerListReq::set_clientversion(::std::string&& value) {
  
  clientversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ClientServerListReq.ClientVersion)
}
#endif
inline void ClientServerListReq::set_clientversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ClientServerListReq.ClientVersion)
}
inline void ClientServerListReq::set_clientversion(const char* value, size_t size) {
  
  clientversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ClientServerListReq.ClientVersion)
}
inline ::std::string* ClientServerListReq::mutable_clientversion() {
  
  // @@protoc_insertion_point(field_mutable:ClientServerListReq.ClientVersion)
  return clientversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientServerListReq::release_clientversion() {
  // @@protoc_insertion_point(field_release:ClientServerListReq.ClientVersion)
  
  return clientversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientServerListReq::set_allocated_clientversion(::std::string* clientversion) {
  if (clientversion != NULL) {
    
  } else {
    
  }
  clientversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientversion);
  // @@protoc_insertion_point(field_set_allocated:ClientServerListReq.ClientVersion)
}

// -------------------------------------------------------------------

// ClientServerNode

// int32 SvrID = 1;
inline void ClientServerNode::clear_svrid() {
  svrid_ = 0;
}
inline ::google::protobuf::int32 ClientServerNode::svrid() const {
  // @@protoc_insertion_point(field_get:ClientServerNode.SvrID)
  return svrid_;
}
inline void ClientServerNode::set_svrid(::google::protobuf::int32 value) {
  
  svrid_ = value;
  // @@protoc_insertion_point(field_set:ClientServerNode.SvrID)
}

// string SvrName = 2;
inline void ClientServerNode::clear_svrname() {
  svrname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientServerNode::svrname() const {
  // @@protoc_insertion_point(field_get:ClientServerNode.SvrName)
  return svrname_.GetNoArena();
}
inline void ClientServerNode::set_svrname(const ::std::string& value) {
  
  svrname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ClientServerNode.SvrName)
}
#if LANG_CXX11
inline void ClientServerNode::set_svrname(::std::string&& value) {
  
  svrname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ClientServerNode.SvrName)
}
#endif
inline void ClientServerNode::set_svrname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  svrname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ClientServerNode.SvrName)
}
inline void ClientServerNode::set_svrname(const char* value, size_t size) {
  
  svrname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ClientServerNode.SvrName)
}
inline ::std::string* ClientServerNode::mutable_svrname() {
  
  // @@protoc_insertion_point(field_mutable:ClientServerNode.SvrName)
  return svrname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientServerNode::release_svrname() {
  // @@protoc_insertion_point(field_release:ClientServerNode.SvrName)
  
  return svrname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientServerNode::set_allocated_svrname(::std::string* svrname) {
  if (svrname != NULL) {
    
  } else {
    
  }
  svrname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), svrname);
  // @@protoc_insertion_point(field_set_allocated:ClientServerNode.SvrName)
}

// int32 SvrState = 3;
inline void ClientServerNode::clear_svrstate() {
  svrstate_ = 0;
}
inline ::google::protobuf::int32 ClientServerNode::svrstate() const {
  // @@protoc_insertion_point(field_get:ClientServerNode.SvrState)
  return svrstate_;
}
inline void ClientServerNode::set_svrstate(::google::protobuf::int32 value) {
  
  svrstate_ = value;
  // @@protoc_insertion_point(field_set:ClientServerNode.SvrState)
}

// int32 SvrFlag = 4;
inline void ClientServerNode::clear_svrflag() {
  svrflag_ = 0;
}
inline ::google::protobuf::int32 ClientServerNode::svrflag() const {
  // @@protoc_insertion_point(field_get:ClientServerNode.SvrFlag)
  return svrflag_;
}
inline void ClientServerNode::set_svrflag(::google::protobuf::int32 value) {
  
  svrflag_ = value;
  // @@protoc_insertion_point(field_set:ClientServerNode.SvrFlag)
}

// int32 SvrOpenTime = 5;
inline void ClientServerNode::clear_svropentime() {
  svropentime_ = 0;
}
inline ::google::protobuf::int32 ClientServerNode::svropentime() const {
  // @@protoc_insertion_point(field_get:ClientServerNode.SvrOpenTime)
  return svropentime_;
}
inline void ClientServerNode::set_svropentime(::google::protobuf::int32 value) {
  
  svropentime_ = value;
  // @@protoc_insertion_point(field_set:ClientServerNode.SvrOpenTime)
}

// -------------------------------------------------------------------

// ClientServerListAck

// uint32 RetCode = 1;
inline void ClientServerListAck::clear_retcode() {
  retcode_ = 0u;
}
inline ::google::protobuf::uint32 ClientServerListAck::retcode() const {
  // @@protoc_insertion_point(field_get:ClientServerListAck.RetCode)
  return retcode_;
}
inline void ClientServerListAck::set_retcode(::google::protobuf::uint32 value) {
  
  retcode_ = value;
  // @@protoc_insertion_point(field_set:ClientServerListAck.RetCode)
}

// repeated .ClientServerNode SvrNode = 2;
inline int ClientServerListAck::svrnode_size() const {
  return svrnode_.size();
}
inline void ClientServerListAck::clear_svrnode() {
  svrnode_.Clear();
}
inline const ::ClientServerNode& ClientServerListAck::svrnode(int index) const {
  // @@protoc_insertion_point(field_get:ClientServerListAck.SvrNode)
  return svrnode_.Get(index);
}
inline ::ClientServerNode* ClientServerListAck::mutable_svrnode(int index) {
  // @@protoc_insertion_point(field_mutable:ClientServerListAck.SvrNode)
  return svrnode_.Mutable(index);
}
inline ::ClientServerNode* ClientServerListAck::add_svrnode() {
  // @@protoc_insertion_point(field_add:ClientServerListAck.SvrNode)
  return svrnode_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ClientServerNode >*
ClientServerListAck::mutable_svrnode() {
  // @@protoc_insertion_point(field_mutable_list:ClientServerListAck.SvrNode)
  return &svrnode_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ClientServerNode >&
ClientServerListAck::svrnode() const {
  // @@protoc_insertion_point(field_list:ClientServerListAck.SvrNode)
  return svrnode_;
}

// -------------------------------------------------------------------

// SelectServerReq

// int32 ServerID = 1;
inline void SelectServerReq::clear_serverid() {
  serverid_ = 0;
}
inline ::google::protobuf::int32 SelectServerReq::serverid() const {
  // @@protoc_insertion_point(field_get:SelectServerReq.ServerID)
  return serverid_;
}
inline void SelectServerReq::set_serverid(::google::protobuf::int32 value) {
  
  serverid_ = value;
  // @@protoc_insertion_point(field_set:SelectServerReq.ServerID)
}

// -------------------------------------------------------------------

// SelectServerAck

// uint32 RetCode = 1;
inline void SelectServerAck::clear_retcode() {
  retcode_ = 0u;
}
inline ::google::protobuf::uint32 SelectServerAck::retcode() const {
  // @@protoc_insertion_point(field_get:SelectServerAck.RetCode)
  return retcode_;
}
inline void SelectServerAck::set_retcode(::google::protobuf::uint32 value) {
  
  retcode_ = value;
  // @@protoc_insertion_point(field_set:SelectServerAck.RetCode)
}

// int32 ServerID = 2;
inline void SelectServerAck::clear_serverid() {
  serverid_ = 0;
}
inline ::google::protobuf::int32 SelectServerAck::serverid() const {
  // @@protoc_insertion_point(field_get:SelectServerAck.ServerID)
  return serverid_;
}
inline void SelectServerAck::set_serverid(::google::protobuf::int32 value) {
  
  serverid_ = value;
  // @@protoc_insertion_point(field_set:SelectServerAck.ServerID)
}

// string ServerAddr = 3;
inline void SelectServerAck::clear_serveraddr() {
  serveraddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SelectServerAck::serveraddr() const {
  // @@protoc_insertion_point(field_get:SelectServerAck.ServerAddr)
  return serveraddr_.GetNoArena();
}
inline void SelectServerAck::set_serveraddr(const ::std::string& value) {
  
  serveraddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SelectServerAck.ServerAddr)
}
#if LANG_CXX11
inline void SelectServerAck::set_serveraddr(::std::string&& value) {
  
  serveraddr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SelectServerAck.ServerAddr)
}
#endif
inline void SelectServerAck::set_serveraddr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serveraddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SelectServerAck.ServerAddr)
}
inline void SelectServerAck::set_serveraddr(const char* value, size_t size) {
  
  serveraddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SelectServerAck.ServerAddr)
}
inline ::std::string* SelectServerAck::mutable_serveraddr() {
  
  // @@protoc_insertion_point(field_mutable:SelectServerAck.ServerAddr)
  return serveraddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SelectServerAck::release_serveraddr() {
  // @@protoc_insertion_point(field_release:SelectServerAck.ServerAddr)
  
  return serveraddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SelectServerAck::set_allocated_serveraddr(::std::string* serveraddr) {
  if (serveraddr != NULL) {
    
  } else {
    
  }
  serveraddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serveraddr);
  // @@protoc_insertion_point(field_set_allocated:SelectServerAck.ServerAddr)
}

// int32 ServerPort = 4;
inline void SelectServerAck::clear_serverport() {
  serverport_ = 0;
}
inline ::google::protobuf::int32 SelectServerAck::serverport() const {
  // @@protoc_insertion_point(field_get:SelectServerAck.ServerPort)
  return serverport_;
}
inline void SelectServerAck::set_serverport(::google::protobuf::int32 value) {
  
  serverport_ = value;
  // @@protoc_insertion_point(field_set:SelectServerAck.ServerPort)
}

// int32 LoginCode = 5;
inline void SelectServerAck::clear_logincode() {
  logincode_ = 0;
}
inline ::google::protobuf::int32 SelectServerAck::logincode() const {
  // @@protoc_insertion_point(field_get:SelectServerAck.LoginCode)
  return logincode_;
}
inline void SelectServerAck::set_logincode(::google::protobuf::int32 value) {
  
  logincode_ = value;
  // @@protoc_insertion_point(field_set:SelectServerAck.LoginCode)
}

// -------------------------------------------------------------------

// LogicRegToLoginReq

// int32 ServerID = 1;
inline void LogicRegToLoginReq::clear_serverid() {
  serverid_ = 0;
}
inline ::google::protobuf::int32 LogicRegToLoginReq::serverid() const {
  // @@protoc_insertion_point(field_get:LogicRegToLoginReq.ServerID)
  return serverid_;
}
inline void LogicRegToLoginReq::set_serverid(::google::protobuf::int32 value) {
  
  serverid_ = value;
  // @@protoc_insertion_point(field_set:LogicRegToLoginReq.ServerID)
}

// string ServerName = 2;
inline void LogicRegToLoginReq::clear_servername() {
  servername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogicRegToLoginReq::servername() const {
  // @@protoc_insertion_point(field_get:LogicRegToLoginReq.ServerName)
  return servername_.GetNoArena();
}
inline void LogicRegToLoginReq::set_servername(const ::std::string& value) {
  
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LogicRegToLoginReq.ServerName)
}
#if LANG_CXX11
inline void LogicRegToLoginReq::set_servername(::std::string&& value) {
  
  servername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LogicRegToLoginReq.ServerName)
}
#endif
inline void LogicRegToLoginReq::set_servername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LogicRegToLoginReq.ServerName)
}
inline void LogicRegToLoginReq::set_servername(const char* value, size_t size) {
  
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LogicRegToLoginReq.ServerName)
}
inline ::std::string* LogicRegToLoginReq::mutable_servername() {
  
  // @@protoc_insertion_point(field_mutable:LogicRegToLoginReq.ServerName)
  return servername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogicRegToLoginReq::release_servername() {
  // @@protoc_insertion_point(field_release:LogicRegToLoginReq.ServerName)
  
  return servername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogicRegToLoginReq::set_allocated_servername(::std::string* servername) {
  if (servername != NULL) {
    
  } else {
    
  }
  servername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), servername);
  // @@protoc_insertion_point(field_set_allocated:LogicRegToLoginReq.ServerName)
}

// string ServerIp = 3;
inline void LogicRegToLoginReq::clear_serverip() {
  serverip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogicRegToLoginReq::serverip() const {
  // @@protoc_insertion_point(field_get:LogicRegToLoginReq.ServerIp)
  return serverip_.GetNoArena();
}
inline void LogicRegToLoginReq::set_serverip(const ::std::string& value) {
  
  serverip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LogicRegToLoginReq.ServerIp)
}
#if LANG_CXX11
inline void LogicRegToLoginReq::set_serverip(::std::string&& value) {
  
  serverip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LogicRegToLoginReq.ServerIp)
}
#endif
inline void LogicRegToLoginReq::set_serverip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serverip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LogicRegToLoginReq.ServerIp)
}
inline void LogicRegToLoginReq::set_serverip(const char* value, size_t size) {
  
  serverip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LogicRegToLoginReq.ServerIp)
}
inline ::std::string* LogicRegToLoginReq::mutable_serverip() {
  
  // @@protoc_insertion_point(field_mutable:LogicRegToLoginReq.ServerIp)
  return serverip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogicRegToLoginReq::release_serverip() {
  // @@protoc_insertion_point(field_release:LogicRegToLoginReq.ServerIp)
  
  return serverip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogicRegToLoginReq::set_allocated_serverip(::std::string* serverip) {
  if (serverip != NULL) {
    
  } else {
    
  }
  serverip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverip);
  // @@protoc_insertion_point(field_set_allocated:LogicRegToLoginReq.ServerIp)
}

// int32 ServerPort = 4;
inline void LogicRegToLoginReq::clear_serverport() {
  serverport_ = 0;
}
inline ::google::protobuf::int32 LogicRegToLoginReq::serverport() const {
  // @@protoc_insertion_point(field_get:LogicRegToLoginReq.ServerPort)
  return serverport_;
}
inline void LogicRegToLoginReq::set_serverport(::google::protobuf::int32 value) {
  
  serverport_ = value;
  // @@protoc_insertion_point(field_set:LogicRegToLoginReq.ServerPort)
}

// int32 HttpPort = 5;
inline void LogicRegToLoginReq::clear_httpport() {
  httpport_ = 0;
}
inline ::google::protobuf::int32 LogicRegToLoginReq::httpport() const {
  // @@protoc_insertion_point(field_get:LogicRegToLoginReq.HttpPort)
  return httpport_;
}
inline void LogicRegToLoginReq::set_httpport(::google::protobuf::int32 value) {
  
  httpport_ = value;
  // @@protoc_insertion_point(field_set:LogicRegToLoginReq.HttpPort)
}

// int32 WatchPort = 6;
inline void LogicRegToLoginReq::clear_watchport() {
  watchport_ = 0;
}
inline ::google::protobuf::int32 LogicRegToLoginReq::watchport() const {
  // @@protoc_insertion_point(field_get:LogicRegToLoginReq.WatchPort)
  return watchport_;
}
inline void LogicRegToLoginReq::set_watchport(::google::protobuf::int32 value) {
  
  watchport_ = value;
  // @@protoc_insertion_point(field_set:LogicRegToLoginReq.WatchPort)
}

// -------------------------------------------------------------------

// LogicRegToLoginAck

// uint32 RetCode = 1;
inline void LogicRegToLoginAck::clear_retcode() {
  retcode_ = 0u;
}
inline ::google::protobuf::uint32 LogicRegToLoginAck::retcode() const {
  // @@protoc_insertion_point(field_get:LogicRegToLoginAck.RetCode)
  return retcode_;
}
inline void LogicRegToLoginAck::set_retcode(::google::protobuf::uint32 value) {
  
  retcode_ = value;
  // @@protoc_insertion_point(field_set:LogicRegToLoginAck.RetCode)
}

// string NewSvrName = 2;
inline void LogicRegToLoginAck::clear_newsvrname() {
  newsvrname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogicRegToLoginAck::newsvrname() const {
  // @@protoc_insertion_point(field_get:LogicRegToLoginAck.NewSvrName)
  return newsvrname_.GetNoArena();
}
inline void LogicRegToLoginAck::set_newsvrname(const ::std::string& value) {
  
  newsvrname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LogicRegToLoginAck.NewSvrName)
}
#if LANG_CXX11
inline void LogicRegToLoginAck::set_newsvrname(::std::string&& value) {
  
  newsvrname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LogicRegToLoginAck.NewSvrName)
}
#endif
inline void LogicRegToLoginAck::set_newsvrname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  newsvrname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LogicRegToLoginAck.NewSvrName)
}
inline void LogicRegToLoginAck::set_newsvrname(const char* value, size_t size) {
  
  newsvrname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LogicRegToLoginAck.NewSvrName)
}
inline ::std::string* LogicRegToLoginAck::mutable_newsvrname() {
  
  // @@protoc_insertion_point(field_mutable:LogicRegToLoginAck.NewSvrName)
  return newsvrname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogicRegToLoginAck::release_newsvrname() {
  // @@protoc_insertion_point(field_release:LogicRegToLoginAck.NewSvrName)
  
  return newsvrname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogicRegToLoginAck::set_allocated_newsvrname(::std::string* newsvrname) {
  if (newsvrname != NULL) {
    
  } else {
    
  }
  newsvrname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), newsvrname);
  // @@protoc_insertion_point(field_set_allocated:LogicRegToLoginAck.NewSvrName)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Msg_5fLogin_2eproto__INCLUDED
